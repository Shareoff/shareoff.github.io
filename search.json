[{"categories":null,"content":"Hello and thanks for joining me for my first blog post! As mentioned in my about page, my main passion at the moment and what I do for a living is learning D and programming in it. Since it‚Äôs not one of the bigger, more famous programming languages, I figure it could be helpful to explain a little what is D, from my POV as a C++ developer, to those of you who may not be familiar.\nWhat is D? From the official site of dlang:\n D is a general-purpose programming language with static typing, systems-level access, and C-like syntax. With the D Programming Language, write fast, read fast, and run fast.\n From Wikipedia:\n Though it originated as a re-engineering of C++, D is a distinct language. It has redesigned some core C++ features, while also sharing characteristics of other languages, notably Java, Python, Ruby, C#, and Eiffel.\nThe design goals of the language attempted to combine the performance and safety of compiled languages with the expressive power of modern dynamic languages. Idiomatic D code is commonly as fast as equivalent C++ code, while also being shorter. The language as a whole is not memory-safe but does include optional attributes designed to check memory safety.\n This means that generally you would use D in applications where you might consider using a language like C or C++. It is much more similar in richness and complexity to C++ than C, so this immediately begs the following question:\nWhy use D (Over C++)? D was clearly designed to be ‚Äúa better C++‚Äù, and it shows. As a result it has many advantages over C++:\nModern Language Features D feels, for the most part, much more like a modern language than C++(17) does. This is because of its built in, immediate and convenient support for many features that have become commonplace in other languages:\nGarbage Collection Coming from C++ (which of course does not have garbage collection and prides itself on manual memory management), using GC (aka Garbage Collection) feels strange. Will my performance take a serious hit? And I‚Äôve spent all this time learning how to manage memory correctly, is it all going to waste?\nThe answer, I find, is actually pretty interesting:\nFirst, the GC is optional, so you may choose not to use it. At weka.io, for example, we disable it for our performance critical section, since speed is a very high priority for us.\nSecond, surprisingly enough, in some cases using GC can be faster! How? Well, because of exceptions and how they are implemented. In C++, it is most correct to deallocate in destructors, which occur when we leave the scope. However, when an exception pops up, we generally need a new and different stack frame, which forces the language to have some special mechanism for holding the old stack frame and calling the destructors of all objects stored on it. So in this case and especially if we use try \u0026 catch statements frequently, it may actually be faster to use GC which does not need to be concerned with such things and works normally.1\nThird, memory management is at least somewhat hard, frustrating and bug prone even if you‚Äôre an expert.2 Developer time spent thinking about memory management, testing for leaks and fixing memory management related bugs is a very valuable resource. If you could, wouldn‚Äôt you rather spend this time on actually working on your core product instead of racking your brain to figure out whether your code could possibly leak?\nSyntax Sugar If you‚Äôre not familiar with the term syntax sugar (or syntactic sugar), here‚Äôs an excerpt I lifted from wikipedia that explains this pretty well:\n In computer science, syntactic sugar is syntax within a programming language that is designed to make things easier to read or to express. It makes the language ‚Äúsweeter‚Äù for human use: things can be expressed more clearly, more concisely, or in an alternative style that some may prefer.\n Because C++ is backwards compatible with C, and how we use the language changed so much since C was created, many basic language features have inconvenient syntax.\nThe simplest example I can think of is pointers, because pointer dereferencing syntax is just annoying and inconvenient to write. Yes, C++ introduced a ‚Äúsolution‚Äù in references, but in reality we still use pointers a ton even in modern C++ and have to deal with pointer dereferencing syntax.\nIn D, you can usually treat pointers as if they‚Äôre already dereferenced, so you can for example access data members normally. Hurray! (Just make sure to check null - they‚Äôre still pointers!)\nNow, you may say, ‚Äúthis doesn‚Äôt sound like a very big deal, why should I care?‚Äù and the answer is, well, I agree it‚Äôs not a big deal, but it is nice, and as a life philosophy, I believe we deserve to enjoy nice things üòâ there are quite a few other small examples like this, and bottom line, it adds up to how enjoyable the code is to write and read.\nNested Functions In D you can define structs, classes and functions inside functions, like in Python. In languages such as C++ and Java you can achieve this by using lambdas (which are also available in D).\nThis could be considered syntax sugar, but in my opinion it has meaningful enough benefits that it‚Äôs worth talking about on its own:\n It allows us to get the benefits of encapsulation, without using classes which feel a little‚Ä¶ cumbersome, or like hitting a zipper with a hammer (in this case at least), because often we would like to separate a function into smaller chunks but we know it‚Äôs unlikely we are going to reuse this smaller code, only for readability, and we would like it to be clear that those code segments are only used inside this function. It lets us use lambdas only when they are truly the most convenient solution, because we have another convenient option.  Contract Programming (AKA Design By Contract) Are you familiar with the concept of ‚Äúdesign by contract‚Äù? I was not until I started learning D, and it‚Äôs pretty cool! The idea is this - functions usually represent a ‚Äúcontract‚Äù. You give me this, I‚Äôll return that, and both clauses of the contract should not be violated. Often, programmers choose to document this information. Which is fine, except we‚Äôd rather the code be self documenting and get the point across by itself.\nThe solution is simple - code blocks built into the language that allow us to specify ‚Äúcontracts‚Äù, which are actually assertions, when entering and leaving the function. It looks like this:\n1 2 3 4 5 6 7 8 9 10 11 12 13  bool func(int var) in { assert(var \u003e 0, \"var should be positive!\"); } out (ret) { assert(ret, \"If this function did not return true something bad happened\"); } do { // actual code here... }   This way, we can write self documenting code that explains exactly how you are and aren‚Äôt supposed to use it! I think that‚Äôs neat.\nTo be perfectly fair, I haven‚Äôt used it so far and it does not seem that many people use it, but I think it is a worthwhile approach to consider and try to use. I like to think of it as a more practical alternative to TDD (Test Driven Development).\nWhat do you think of D so far? not bad, right? But it‚Äôs likely you‚Äôre not falling off your seat. That‚Äôs okay, because now we‚Äôre getting to the real meat of things:\nCompile Time Programming Features This is the real selling point of D, and it allows you to do all sorts of amazing things.\nWhat C++ Offers Can we run code in compile time in C++? Yes, and a fun piece of trivia many know is that C++ templates are Turing complete, which is kind of cool, but to those of us who have tried to use some of those alleged Turing-complete capabilities, it‚Äôs also incredibly horrifying: when you try to implement anything but the most basic functionality with templates in C++, things get ugly, FAST.\nThe syntax is horrible and it constantly feels like you‚Äôre wrestling the language to get it to do what you want. You have to know some pretty obscure language rules really well, which are never relevant otherwise and are often not intuitive. Add to that the lack of debug tools in compile time with horrendous compilation errors, and the result is that trying to develop complicated features in compile time becomes highly impractical.\nWhy should you care? Well, for one example, this means that in some cases we opt to generate C++ code with a scripting language, which works, but has all sorts of maintainability issues and almost always ends up being a huge pile of technical debt.3\nIn C++17 and C++20, we got a whole bunch of functionality to aid in compile time programming (if statements at compile time, a more convenient syntax for placing limitations on template types, etc). Even still, template meta-programming remains an extremely daunting task.\nThe bottom line is that originally template meta-programming was not intentionally created, for the most part, by the C++ committee, but rather created accidentally and discovered through research of the language. To make these features convenient to use, the whole thing needs a redesign. Unfortunately, C++ has to be backwards compatible to older C++ and even to C so such a redesign is impossible.\nEnter D. One of D‚Äôs main missions was to improve this, specifically. In fact, one of the founders of the D programming language, Andrei Alexandrescu, wrote one of the best C++ books on template meta-programming (he kind of popularized the concept, really), Modern C++ Design. This book gets pretty dense and hard to implement (remember? These were not really intentional language features, but kind of an abuse of the language), so he implemented some of its conclusions himself into a library called Loki. So basically, what I‚Äôm trying to say here is this guy knows his shit.\nAlexandrescu has been involved in the development of D from pretty early on, and together with the other creators of the language, they made sure it was made from the get-go to solve many of the problems C++ compile time programmers ran into. D has a multitude of additional features that make your code so much better if you are trying to write compile-time code and some of these features even ended up finding their way back to C++ (but of course, not all of them - if that were possible, we wouldn‚Äôt need another language).\nTo fully explain all the amazing features that are involved to make D compile time so great this post would have to be at least twice as long, and it‚Äôs already getting wordy (whew!). But in addition to C++-like templates with much of their original power and type deduction in the form of auto, D added traits, mixin, and User Defined Attributes (UDA), each of which add an insane amount of power to the language!\nThis makes it so your D project is much more self contained, because many things for which you would need to write tools in a scripting language, like code generation and compile-time checks, can be done inside your main code base, relatively conveniently and easily! D is a very easy choice4 if you want a language that solves this problem well, it is really that good.\nIf you‚Äôre anything like me, here comes the part where you go, ‚ÄúWell, that sounds great. D is basically the perfect C++ replacement. So why isn‚Äôt the entire world using D?‚Äù\nWhy (I think) D has not replaced C++ The truth is, D is not very popular. I can‚Äôt be sure what, exactly, is the combination of limitations that made so many developers not choose to move to D. But there are a few things that cannot be ignored and are worth mentioning.\nImperfect C++ Integration It is rare projects are completely written from scratch, and often projects already have a respectable existing code base in C++. The good news is that D‚Äôs C++ integration is actually some of the best on the market - most languages only natively support interfacing with C, and then you have to go through some hoops to integrate your C++ code.\nThe bad news is that it has some limitations, it requires a bit of work and often ends up being impractical for larger projects or libraries. This in itself is somewhat of a problem, but really it only serves to make the next problem even more severe:\nSmall Community, No Libraries This kind of cycle is very hard to break out of - D does not have the external library support that a language such as C++ has, because it‚Äôs smaller, and since you don‚Äôt integrate flawlessly with C++ it‚Äôs not always worth the effort to try and use a C++ library. So many developers choose the language which has more external libraries, which leads to less libraries being developed, which leads to less developers choosing D, etc.\nUnfortunately, when writing D, other than the standard library, the ecosystem is a bit thin and you don‚Äôt end up relying on external libraries very often. For the most part, that‚Äôs a bad thing, because you end up doing a lot of extra work.\nBut there‚Äôs another factor, kind of ‚Äúrandom‚Äù maybe, or perhaps a twist of fate, but unfortunately for the D language,\nRust Exists The Rust programming language is a pretty new language; it was developed after D, and it aims to fill a similar niche: ‚ÄúC++, but better‚Äù. And while Rust does not quite have the compile time capabilities of D, it has a different focus, not any less important: security. While D is somewhat more secure and less error prone than C++, Rust is leaps and bounds ahead of both of them.\nRegardless of which approach or language is better, which is a debate I do not feel qualified to participate in, Rust emerged in a perfect storm of coming into a world where ‚Äúsecurity‚Äù is one of the biggest buzzwords floating around (while ‚Äútemplate metaprogramming‚Äù was not the theme of the 2010s for most of the programming world üòú), and it rose to answer this need of the industry well. As a result, in many cases where a company might choose D, they ended up choosing this newer and somewhat shinier option.\nConclusion TL;DR D is a really cool language that improves on C++ in almost every way imaginable. However it has not fully taken off and it looks kind of unlikely it will. Its compile time programming features are particularly noteworthy, making it possibly the best language for writing compile time code4. It allows you to write beautiful code, which is what we all want, while having C++-like performance.\nPersonal Note I am personally really enjoying learning D - it is a language with a lot of depth which is very enjoyable for me, but for the most part it is relatively easy and intuitive to learn as a C++ developer. And seeing the ways its compile time capabilities are used in our code base at my company weka.io and in most D code bases is mind blowing and extremely satisfying. Either way, it is going to be a major part of my life for a while, so I hope you‚Äôll join me here while I explore the intricacies of D!\nFurther Reading If you‚Äôre interested and would like to read (or hear) more, here are some resources I can personally recommend:\n  https://dlang.org/\nThe D official website, which includes a good amount of learning resources and documentation\n  http://ddili.org/ders/d.en/index.html\nAn online book called Programming In D which teaches D from scratch\n  https://wiki.dlang.org/The_D_Programming_Language\nThe D wiki\n  https://www.youtube.com/channel/UC5DNdmeE-_lS6VhCVydkVvQ\nThe official youtube channel of the D language, has lectures from DConf (the annual D conference)\n    Of course, frequent use of exceptions and try/catch statements is not recommended for performance critical code. In these cases, it is unlikely GC will match manual memory management for performance. ‚Ü©Ô∏é\n Don‚Äôt believe me? Watch this excellent lecture by Herb Sutter, who is a well respected figure in the C++ community - he‚Äôs particularly famous for writing great books such as the Exceptional C++ series. In short, he provides many solutions for what he calls ‚Äúby default‚Äù memory management - simply using the correct memory managing types and relying on destructors to write sound code which will not leak.\nThis in itself requires you to have a decent amount of C++ knowledge to correctly implement, but then comes the kicker - he presents a case, not very theoretical or far-fetched, for which there is currently no good solution in C++! And then comes up with a solution himself, which is actually incredibly dense and complicated. As far as I know, there is no easy method or agreed upon consensus on how to solve this problem to this day. ‚Ü©Ô∏é\n Speaking from my personal experience here so of course I could be wrong. If you know of python that generates C++ as a small part of a larger C++ project that is easy to maintain and convenient to use let me know and I will gladly correct myself. Unfortunately, I‚Äôve seen multiple code generating systems designed from scratch and have been involved in a few of them and the costs of having something like that in your project are almost always higher than you might think. ‚Ü©Ô∏é\n Lisp is the other language that I hear has very strong compile time capabilities, perhaps more so than D. Still, D beats out practically every other language on this front, which makes it an excellent option. ‚Ü©Ô∏é\n   ","description":"It‚Äôs just like C, except it‚Äôs D. Well, kind of‚Ä¶","subtitle":"The inevitable C++ versus D comparison","tags":["D"],"title":"What is D (Dlang)?","uri":"/posts/what-is-d/"},{"categories":null,"content":"Hello and welcome to my blog, Obsessed With Details!\nWhat is this blog? Thoughts about general software engineering, the startup culture in Israel, programming languages such as C++, D and Python. In other words, any professional musings I have that (hopefully) could be interesting.\nWho are you? My name is Sharon Hadas, and I‚Äôm a software developer currently working at a storage startup located in Tel Aviv called weka.io. This job has been posing many interesting challenges - for example, learning a language called D, also known as dlang, from scratch, as well as learning about the storage world. My background is mostly in C++, and so I felt I wanted a place to document my thoughts and things I have been learning. The D language community is relatively small, so there‚Äôs not a ton of resources around, and I was hoping my efforts could be useful to others.\nIn addition to writing about D, I spent a good few years honing my C++ skills, and I would like to keep myself fresh and practice my knowledge. It‚Äôs also very important to me to keep my C++ expertise up to date, because despite what some may think C++ in the last few years is actually changing quite fast.\nWhy ‚ÄúObsessed With Details‚Äù? Because I love taking the deep dive into concepts and fully deconstructing them into tiny little details, where each nugget is easy enough to understand on its own. And also because I hope it sounds cool :p\nAre comments welcome? Yes! Part of the reason I created this blog is because I‚Äôd really like to have a richer community around me for professional discussion. Feel free to use the in-site comments system, or you can email me at sharonhadas7@gmail.com. I‚Äôd love to hear your thoughts!\nHow can I stay updated on new posts? You can sign up to my mailing list here. I will send an email when I publish a new post, which I estimate should be about once or twice a month. Thanks for taking an interest in my blog!\n","description":"What is this blog? Who are you? And how the hell did I get here?","tags":null,"title":"About","uri":"/about/"}]
